<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Canvas</title>
    <style type="text/css">
        #test-canvas, #test-text-canvas {
            border: 1px solid #f90;
            margin: 0 auto;
        }
        canvas {
            border: 1px solid #eee;
        }
    </style>
</head>
<body>

<p>Canvas的坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。</p>

<h2>Canvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。如果要实现非常复杂的操作，考虑以下优化方案：</h2>

<p>通过创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中；</p>

<p>尽量使用整数坐标而不是浮点数；</p>

<p>可以创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图；</p>
<p>canvas 元素默认被网格所覆盖。通常来说网格中的一个单元相当于 canvas 元素中的一像素。栅格的起点为左上角，坐标为 (0,0) 。<br>
    所有元素的位置都相对于原点来定位。所以图中蓝色方形左上角的坐标为距离左边（X 轴）x 像素，距离上边（Y 轴）y 像素，坐标为 (x,y)。</p>
<p>后面我们会涉及到坐标原点的平移、网格的旋转以及缩放等。</p>
<p>背景图片如果不变可以直接用<img>标签并放到最底层。</p>
<canvas id="test-canvas" width="300" height="300">
    <p>你的浏览器太老了，该升级了，不支持canvas</p>
</canvas>

<canvas id="test-text-canvas" width="300" height="300"></canvas>
<canvas id="canvas1" width="300" height="300"></canvas>
<canvas id="canvas2" width="300" height="300"></canvas>
</body>
<script>
    window.onload = () => {
        testCanvas()
        testTextCanvas()
        draw1()
    }
    function testCanvas () {
        let canvas = document.getElementById('test-canvas')
        // 检测支持性
        if (canvas.getContext) {
            // 获得 2d 上下文对象
            let ctx = canvas.getContext('2d')
            ctx.clearRect(0, 0, 200, 200) // 擦除(0,0)位置大小为200x200的矩形，擦除的意思是把该区域变为透明
            ctx.fillStyle = '#c8fdff' // 设置颜色
            ctx.fillRect(10, 10, 130, 130); // 把(10,10)位置大小为130x130的矩形涂色
            // 利用Path绘制复杂路径:
            let path = new Path2D()
            path.arc(75, 75, 50, 0, Math.PI * 2, true)
            path.moveTo(110, 75)
            path.arc(75, 75, 35, 0, Math.PI, false)
            path.moveTo(65, 65)
            path.arc(60, 65, 5, 0, Math.PI * 2, true)
            path.moveTo(95, 65)
            path.arc(90, 65, 5, 0, Math.PI * 2, true)
            ctx.strokeStyle = '#f60'
            ctx.stroke(path)
            // 3d
            // let gl = canvas.getContext('webgl')
        } else {
            console.log('你的浏览器不支持Canvas!');
        }
    }
    function testTextCanvas () {
        let canvas = document.getElementById('test-text-canvas')
        if (canvas.getContext) {
            // 2d
            let ctx = canvas.getContext('2d')
            ctx.clearRect(0, 0, canvas.width, canvas.height)
            ctx.shadowOffsetX = 2
            ctx.shadowOffsetY = 3
            ctx.shadowBlur = 2
            ctx.shadowColor = '#ff6942'
            ctx.font = '24px Arial'
            ctx.fillStyle = '#333'
            ctx.fillText('绘制文本', 20, 40)
            // 3d
            // let gl = canvas.getContext('webgl')
        } else {
            console.log('你的浏览器不支持Canvas!');
        }
    }

    /**
     * 绘制矩形
     * 1、fillRect(x, y, width, height)：绘制一个填充的矩形。
     * 2、strokeRect(x, y, width, height)：绘制一个矩形的边框。
     * 3、clearRect(x, y, widh, height)：清除指定的矩形区域，然后这块区域会变的完全透明。
     * x, y：指的是矩形的左上角的坐标。(相对于canvas的坐标原点)
     * width, height：指的是绘制的矩形的宽和高。
     */
    function draw1 () {
        let canvas = document.getElementById('canvas1')
        if(!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.fillRect(10, 10, 100, 50) // 绘制矩形，填充的默认颜色为黑色
        ctx.strokeRect(10, 70, 100, 50) // 绘制矩形边框
        ctx.clearRect(15, 15, 50, 25); // 清除指定的矩形区域，然后这块区域会变的完全透明。
    }

    /**
     * 绘制路径 (path)
     *
     *  图形的基本元素是路径。
     *  路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。
     *  一个路径，甚至一个子路径，都是闭合的。
     *
     * 使用路径绘制图形需要一些额外的步骤：
     *   1.创建路径起始点
     *   2.调用绘制方法去绘制出路径
     *   3.把路径封闭
     *   4.一旦路径生成，通过描边或填充路径区域来渲染图形。
     * 下面是需要用到的方法：
     *    1.beginPath()   新建一条路径，路径一旦创建成功，图形绘制命令被指向到路径上生成路径
     *    2.moveTo(x, y)   把画笔移动到指定的坐标(x, y)。相当于设置路径的起始点坐标。
     *    3.closePath()   闭合路径之后，图形绘制命令又重新指向到上下文中
     *    4.stroke()  通过线条来绘制图形轮廓
     *    5.fill()  通过填充路径的内容区域生成实心的图形
     */
    function draw2 () {
        let canvas = document.getElementById('canvas2')
        if(!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
    }
</script>
</html>
