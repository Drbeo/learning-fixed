[垃圾回收](https://zh.javascript.info/garbage-collection)
### 可达性（Reachability）
简而言之，“可达”值是那些以某种方式可访问或可用的值。它们一定是存储在内存中的。
1. 这里列出固有的可达值的基本集合，这些值明显不能被释放。

比方说：
* 当前函数的局部变量和参数。
* 嵌套调用时，当前调用链上所有函数的变量与参数。
* 全局变量。
* （还有一些内部的）

这些值被称作 根（roots）。

2. 如果一个值可以通过引用或引用链从根访问任何其他值，则认为该值是可达的。

比方说，如果全局变量中有一个对象，并且该对象有一个属性引用了另一个对象，则该对象被认为是可达的。  
而且它引用的内容也是可达的。下面是详细的例子。

在 JavaScript 引擎中有一个被称作 **垃圾回收器** 的东西在后台执行。  
它监控着所有对象的状态，并删除掉那些已经不可达的。
对象的值被重写了，这个引用就没了，因为没有引用了，就不能访问到它了。  
垃圾回收器会认为它是垃圾数据并进行回收，然后释放内存。

### 内部算法

垃圾回收的基本算法被称为 “mark-and-sweep”。

定期执行以下“垃圾回收”步骤：

* 垃圾收集器找到所有的根，并“标记”（记住）它们。
* 然后它遍历并“标记”来自它们的所有引用。
* 然后它遍历标记的对象并标记 他们的 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。
* ……如此操作，直到所有可达的（从根部）引用都被访问到。
* 没有被标记的对象都会被删除。

我们还可以将这个过程想象成从根溢出一个巨大的油漆桶，它流经所有引用并标记所有可到达的对象。然后移除未标记的。

这是垃圾收集工作的概念。JavaScript 引擎做了许多优化，使垃圾回收运行速度更快，并且不影响正常代码运行。

* 分代收集（Generational collection）—— 对象被分成两组：“新的”和“旧的”。许多对象出现，完成他们的工作并很快死去，他们可以很快被清理。那些长期存活的对象会变得“老旧”，而且被检查的频次也会减少。
* 增量收集（Incremental collection）—— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。所以引擎试图将垃圾收集工作分成几部分来做。然后将这几部分会逐一进行处理。这需要他们之间有额外的标记来追踪变化，但是这样会有许多微小的延迟而不是一个大的延迟。
* 闲时收集（Idle-time collection）—— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。
