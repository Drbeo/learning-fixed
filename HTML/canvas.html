<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Canvas</title>
    <style type="text/css">
        body {
            margin: 100px;
        }
        /*#test-canvas, #test-text-canvas {*/
        /*    border: 1px solid #f90;*/
        /*    margin: 0 auto;*/
        /*}*/
        canvas {
            border: 1px solid #eee;
        }
        img {
            max-width: 300px;
            max-height: 300px;
            object-fit: scale-down;
            vertical-align: top;
        }
        .img1 {
            display: none;
        }
    </style>
</head>
<body>
<section>
    <p>Canvas的坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴，以像素为单位，所以每个点都是非负整数。</p>

    <h2>Canvas除了能绘制基本的形状和文本，还可以实现动画、缩放、各种滤镜和像素转换等高级操作。如果要实现非常复杂的操作，考虑以下优化方案：</h2>

    <p>通过创建一个不可见的Canvas来绘图，然后将最终绘制结果复制到页面的可见Canvas中；</p>

    <p>尽量使用整数坐标而不是浮点数；</p>

    <p>可以创建多个重叠的Canvas绘制不同的层，而不是在一个Canvas中绘制非常复杂的图；</p>
    <p>canvas 元素默认被网格所覆盖。通常来说网格中的一个单元相当于 canvas 元素中的一像素。栅格的起点为左上角，坐标为 (0,0) 。<br>
        所有元素的位置都相对于原点来定位。所以图中蓝色方形左上角的坐标为距离左边（X 轴）x 像素，距离上边（Y 轴）y 像素，坐标为 (x,y)。</p>
    <p>后面我们会涉及到坐标原点的平移、网格的旋转以及缩放等。</p>
    <p>背景图片如果不变可以直接用< img>标签并放到最底层。</p>
</section>
<canvas id="test-canvas" width="300" height="300">
    <p>你的浏览器太老了，该升级了，不支持canvas</p>
</canvas>

<canvas id="test-text-canvas" width="300" height="300"></canvas>
<canvas id="scaleCircle" width="400" height="300"></canvas>
<h2>绘制形状</h2>
<section>
    <pre>
        栅格 (grid) 和坐标空间
        如下图所示，canvas 元素默认被网格所覆盖。通常来说网格中的一个单元相当于 canvas 元素中的一像素。
        栅格的起点为左上角，坐标为 (0,0) 。所有元素的位置都相对于原点来定位。
        所以图中蓝色方形左上角的坐标为距离左边（X 轴）x 像素，距离上边（Y 轴）y 像素，坐标为 (x,y)。
        后面我们会涉及到坐标原点的平移、网格的旋转以及缩放等。
    </pre>
    <img src="./assets/canvas/Canvas_default_grid.png" alt="">
    <pre>
        <​canvas> 只支持一种原生的图形绘制：矩形。
        所有其他图形都至少需要生成一种路径 (path)。不过，我们拥有众多路径生成的方法让复杂图形的绘制成为了可能。

        canvas 提供了三种方法绘制矩形：
            1、fillRect(x, y, width, height)：绘制一个填充的矩形。
            2、strokeRect(x, y, width, height)：绘制一个矩形的边框。
            3、clearRect(x, y, widh, height)：清除指定的矩形区域，然后这块区域会变的完全透明。
        说明：这 3 个方法具有相同的参数。
            x, y：指的是矩形的左上角的坐标。(相对于canvas的坐标原点)
            width, height：指的是绘制的矩形的宽和高。
    </pre>
    <canvas id="canvas1" width="300" height="300"></canvas>
</section>
<h2>绘制路径 (path)</h2>
<section>
    <pre>
        图形的基本元素是路径。
        路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。
        一个路径，甚至一个子路径，都是闭合的。
        使用路径绘制图形需要一些额外的步骤：
            1.创建路径起始点
            2.调用绘制方法去绘制出路径
            3.把路径封闭
            4.一旦路径生成，通过描边或填充路径区域来渲染图形。
        下面是需要用到的方法：
            1.beginPath()   新建一条路径，路径一旦创建成功，图形绘制命令被指向到路径上生成路径
            2.moveTo(x, y)  把画笔移动到指定的坐标(x, y)。相当于设置路径的起始点坐标。
            3.closePath()   闭合路径之后，图形绘制命令又重新指向到上下文中
            4.stroke()      通过线条来绘制图形轮廓
            5.fill()        通过填充路径的内容区域生成实心的图形
    </pre>
    <canvas id="canvas2" width="300" height="300"></canvas>
    <canvas id="canvas3" width="300" height="300"></canvas>
    <canvas id="canvas4" width="300" height="300"></canvas>
    <canvas id="canvas5" width="300" height="300"></canvas>
</section>
<h2>绘制圆弧</h2>
<section>
    <pre>
        绘制圆弧
        有两个方法可以绘制圆弧：
        1. arc(x, y, r, startAngle, endAngle, anticlockwise):
        以(x, y)为圆心，以r为半径，从 startAngle弧度开始到endAngle弧度结束。anticlosewise是布尔值，true表示逆时针，false表示顺时针(默认是顺时针)。
        注意：
            1. 这里的度数都是弧度。
            2. 0 弧度是指的 x 轴正方形。
            radians=(Math.PI/180)*degrees   //角度转换成弧度
        2、arcTo(x1, y1, x2, y2, radius): 根据给定的控制点和半径画一段圆弧，最后再以直线连接两个控制点。
    </pre>
    <canvas id="canvas6" width="300" height="300"></canvas>
    <canvas id="canvas7" width="300" height="300"></canvas>
    <canvas id="canvas8" width="300" height="300"></canvas>
    <img src="./assets/canvas/arcTo.png" alt="">
</section>
<h2>绘制贝塞尔曲线</h2>
<section>
    <pre>
        贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。
        一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋，
        我们在绘图工具上看到的钢笔工具就是来做这种矢量曲线的。
        贝塞尔曲线是计算机图形学中相当重要的参数曲线，在一些比较成熟的位图软件中也有贝塞尔曲线工具如 PhotoShop 等。
        贝塞尔曲线于 1962，由法国工程师皮埃尔·贝塞尔（Pierre Bézier）所广泛发表，他运用贝塞尔曲线来为汽车的主体进行设计。
        贝塞尔曲线最初由Paul de Casteljau 于 1959 年运用 de Casteljau 演算法开发，以稳定数值的方法求出贝兹曲线。
    </pre>
    <article>
        <h3>一次贝塞尔曲线其实是一条直线</h3>
        <img src="./assets/canvas/Bezier1.gif" alt="">
    </article>
    <article>
        <h3>二次贝塞尔曲线</h3>
        <img src="./assets/canvas/Bezier2.gif" alt="">
        <img src="./assets/canvas/Bezier22.png" alt="">
    </article>
    <article>
        <h3>三次贝塞尔曲线</h3>
        <img src="./assets/canvas/Bezier3.gif" alt="">
        <img src="./assets/canvas/Bezier33.png" alt="">
    </article>
    <canvas id="canvas9" width="300" height="300"></canvas>
    <canvas id="canvas10" width="300" height="300"></canvas>
</section>
<h2>添加样式和颜色</h2>
<section>
    <pre>
        在前面的绘制矩形章节中，只用到了默认的线条和颜色。
        如果想要给图形上色，有两个重要的属性可以做到。
            fillStyle = color 设置图形的填充颜色
            strokeStyle = color 设置图形轮廓的颜色
            说明
                1. color 可以是表示 css 颜色值的字符串、渐变对象或者图案对象。
                2. 默认情况下，线条和填充颜色都是黑色。
                3. 一旦您设置了 strokeStyle 或者 fillStyle 的值，那么这个新值就会成为新绘制的图形的默认值。
                如果你要给每个图形上不同的颜色，你需要重新设置 fillStyle 或 strokeStyle 的值。
    </pre>
    <canvas id="canvas11" width="300" height="300"></canvas>
    <canvas id="canvas12" width="300" height="300"></canvas>
</section>
<h2>常用样式</h2>
<section>
    <pre>
        Transparency(透明度)
            globalAlpha = transparencyValue: 这个属性影响到 canvas 里 所有 图形的透明度，
               有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。
            globalAlpha 属性在需要绘制大量拥有相同透明度的图形时候相当高效。

            不过，使用rgba()设置透明度更加好一些。

        1、line style
            线宽。只能是正值。默认是 1.0。
            起始点和终点的连线为中心，上下各占线宽的一半。

        2. lineCap = type
            线条末端样式。
            共有 3 个值：
                butt：线段末端以方形结束
                round：线段末端以圆形结束
                square：线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域。

        3. lineJoin = type
            同一个 path 内，设定线条与线条间接合处的样式。
            共有 3 个值 round, bevel 和 miter：
                round 通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状。 圆角的半径是线段的宽度。
                bevel 在相连部分的末端填充一个额外的以三角形为底的区域， 每个部分都有各自独立的矩形拐角。
                miter(默认) 通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域。

        4. 虚线
            用 setLineDash 方法和 lineDashOffset 属性来制定虚线样式。
            setLineDash 方法接受一个数组，来指定线段与间隙的交替；lineDashOffset属性设置起始偏移量。
            getLineDash() 返回一个包含当前虚线样式，长度为非负偶数的数组。
    </pre>
    <canvas id="canvas13" width="300" height="300"></canvas>
    <canvas id="canvas14" width="300" height="300"></canvas>
    <canvas id="canvas15" width="300" height="300"></canvas>
    <canvas id="canvas16" width="300" height="300"></canvas>
</section>
<h2>绘制文本</h2>
<section>
    <pre>
        绘制文本的两个方法
            fillText(text, x, y [, maxWidth]) 在指定的 (x,y) 位置填充指定的文本，绘制的最大宽度是可选的。
            strokeText(text, x, y [, maxWidth]) 在指定的 (x,y) 位置绘制文本边框，绘制的最大宽度是可选的。

        给文本添加样式
            font = value 当前我们用来绘制文本的样式。这个字符串使用和 CSS font 属性相同的语法。 默认的字体是 10px sans-serif。
            textAlign = value 文本对齐选项。 可选的值包括：start, end, left, right or center。 默认值是 start。
            textBaseline = value 基线对齐选项，可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。。
            direction = value 文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。
    </pre>
    <canvas id="canvas17" width="300" height="300"></canvas>
</section>
<h2>绘制图片</h2>
<section>
    <pre>
        由零开始创建图片
            var img = new Image();   // 创建一个< img>元素
            img.src = 'myImage.png'; // 设置图片源地址

        绘制 img
            ctx.drawImage(img,0,0);  // 参数1：要绘制的img, 参数2、3：绘制的img在canvas中的坐标

        注意：考虑到图片是从网络加载，如果 drawImage 的时候图片还没有完全加载完成，则什么都不做，个别浏览器会抛异常。所以我们应该保证在 img 绘制完成之后再 drawImage。
            var img = new Image();   // 创建img元素
            img.onload = function(){
                ctx.drawImage(img, 0, 0) // 绘制 img
            }
            img.src = 'myImage.png'; // 设置图片源地址

        img 可以 new 也可以来源于我们页面的 < img>标签。

        缩放图片
            drawImage(image, x, y, width, height) // 图片 x，y 坐标  width, height  图片尺寸

        切片(slice)
            drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)  // 图片 前4个是定义图像源的切片位置和大小，后4个则是定义切片的目标显示位置和大小。
    </pre>
    <canvas id="canvas18" width="300" height="300"></canvas>
    <canvas id="canvas19" width="300" height="300"></canvas>
    <img class="img" src="./assets/canvas/666666.png" alt="">
    <br>
    <img class="img1" src="./assets/canvas/鸟.jpg" alt="">
    <canvas id="canvas20" width="300" height="300"></canvas>
    <canvas id="canvas21" width="300" height="300"></canvas>
    <img src="./assets/canvas/slice.jpeg" alt="">
</section>
<h2>状态的保存和恢复</h2>
<section>
    <pre>
        Saving and restoring state 是绘制复杂图形时必不可少的操作。

        save() 和 restore()
            save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。

        Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。

        1、关于 save() ：Canvas状态存储在栈中，每当save()方法被调用后，当前的状态就被推送到栈中保存。
           一个绘画状态包括：
              1. 当前应用的变形（即移动，旋转和缩放）
              2. strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit,
                 shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation 的值
              3. 当前的裁切路径（clipping path）

        *** 可以调用任意多次 save方法(类似数组的 push())。

        2、关于restore()：每一次调用 restore 方法，上一个保存的状态就从栈中弹出，所有设定都恢复(类似数组的 pop())。
    </pre>
    <canvas id="canvas22" width="300" height="300"></canvas>
</section>
<h2>变形</h2>
<section>
    <pre>
        1、translate  用来移动 canvas 的**原点**到指定的位置
             translate(x, y) // x 是左右偏移量，y 是上下偏移量
          在做变形之前先保存状态是一个良好的习惯。大多数情况下，调用 restore 方法比手动恢复原先的状态要简单得多。
          又如果你是在一个循环中做位移但没有保存和恢复 canvas 的状态，很可能到最后会发现怎么有些东西不见了，那是因为它很可能已经超出 canvas 范围以外了。
          注意：translate 移动的是 canvas 的坐标原点(坐标变换)。

        2、rotate  旋转坐标轴。
             rotate(angle)  // angle 旋转的角度 它是顺时针方向的，以弧度为单位的值。旋转的中心是坐标原点。

        3、scale   增减图形在 canvas 中的像素数目，对形状，位图进行缩小或者放大。
             scale(x, y)  // x,y分别是横轴和纵轴的缩放因子，它们都必须是正值。值比 1.0 小表示缩 小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有。

        4.transform(变形矩阵)
             transform(a, b, c, d, e, f)
                 a 水平缩放
                 b 水平偏斜
                 c 垂直偏斜
                 d 垂直缩放
                 e 水平移动
                 f 垂直移动
    </pre>
    <img src="./assets/canvas/translate.png" alt="">
    <canvas id="canvas23" width="300" height="300"></canvas>
    <br>
    <img src="./assets/canvas/rotate.png" alt="">
    <canvas id="canvas24" width="300" height="300"></canvas>
    <br>
    <canvas id="canvas25" width="300" height="300"></canvas>
    <br>
    <img src="./assets/canvas/transform.jpg" alt="">
    <canvas id="canvas26" width="300" height="300"></canvas>
</section>
<h2>合成</h2>
<section>
    <pre>
        globalCompositeOperation = type

        在前面的所有例子中、，我们总是将一个图形画在另一个之上，对于其他更多的情况，仅仅这样是远远不够的。
        比如，对合成的图形来说，绘制顺序会有限制。不过，我们可以利用 globalCompositeOperation 属性来改变这种状况。
        合成
            globalCompositeOperation = type
            type
                1.source-over 默认设置，新图像会覆盖在原有图像。
                2.source-in 仅仅会出现新图像与原来图像重叠部分的新图像，其他区域都变成透明的。(包括其他的老图像区域也会透明)
                3.source-out 仅仅显示新图像与老图像没有重叠部分的新图像，其余部分全部透明。(老图像也不显示)
                4.source-atop 新图像仅仅显示与老图像重叠区域。老图像仍然可以显示。
                5.destination-over 新图像会在老图像的下面。
                6.destination-in 仅仅新老图像重叠部分的老图像被显示，其他区域全部透明。
                7.destination-out 仅仅老图像与新图像没有重叠的部分。 注意显示的是老图像的部分区域。
                8.destination-atop 老图像仅仅仅仅显示重叠部分，新图像会显示在老图像的下面。
                9.lighter 新老图像都显示，但是重叠区域的颜色做加处理。(每个颜色位进行相加) blue: #0066ff  red: #ff6600  所以重叠部分的颜色：#ffccff。
                10.darken 保留重叠部分最黑的像素。(每个颜色位进行比较，得到最小的)  blue: #0000ff  red: #ff0000  所以重叠部分的颜色：#000000。
                11.lighten 保证重叠部分最亮的像素。(每个颜色位进行比较，得到最大的) blue: #0000ff  red: #ff0000  所以重叠部分的颜色：#ff00ff。
                12.xor 重叠部分会变成透明。
                13.copy 只有新图像会被保留，其余的全部被清除(边透明)。
    </pre>
    <canvas id="canvas27" width="300" height="300"></canvas>
    <canvas id="canvas28" width="300" height="300"></canvas>
    <canvas id="canvas29" width="300" height="300"></canvas>
    <canvas id="canvas30" width="300" height="300"></canvas>
    <canvas id="canvas31" width="300" height="300"></canvas>
    <canvas id="canvas32" width="300" height="300"></canvas>
    <canvas id="canvas33" width="300" height="300"></canvas>
    <canvas id="canvas34" width="300" height="300"></canvas>
    <canvas id="canvas35" width="300" height="300"></canvas>
    <canvas id="canvas36" width="300" height="300"></canvas>
    <canvas id="canvas37" width="300" height="300"></canvas>
    <canvas id="canvas38" width="300" height="300"></canvas>
    <canvas id="canvas39" width="300" height="300"></canvas>
</section>
<h2>裁剪路径</h2>
<section>
    <pre>
        裁剪路径
            clip()

            把已经创建的路径转换成裁剪路径。
            裁剪路径的作用是遮罩。只显示裁剪路径内的区域，裁剪路径外的区域会被隐藏。
                注意：clip() 只能遮罩在这个方法调用之后绘制的图像，如果是 clip() 方法调用之前绘制的图像，则无法实现遮罩。
    </pre>
    <img src="./assets/canvas/clip().png" alt="">
    <canvas id="canvas40" width="300" height="300"></canvas>
</section>
<h2>动画</h2>
<section>
    <pre>

    </pre>
    <canvas id="canvas41" width="300" height="300"></canvas>
    <canvas id="canvas42" width="300" height="300"></canvas>
    <canvas id="canvas43" width="300" height="300"></canvas>
</section>
</body>
<script>
    function testCanvas () {
        let canvas = document.getElementById('test-canvas')
        // 检测支持性
        if (canvas.getContext) {
            // 获得 2d 上下文对象
            let ctx = canvas.getContext('2d')
            ctx.clearRect(0, 0, 200, 200) // 擦除(0,0)位置大小为200x200的矩形，擦除的意思是把该区域变为透明
            ctx.fillStyle = '#c8fdff' // 设置颜色
            ctx.fillRect(10, 10, 130, 130); // 把(10,10)位置大小为130x130的矩形涂色
            // 利用Path绘制复杂路径:
            let path = new Path2D()
            path.arc(75, 75, 50, 0, Math.PI * 2, true)
            path.moveTo(110, 75)
            path.arc(75, 75, 35, 0, Math.PI, false)
            path.moveTo(65, 65)
            path.arc(60, 65, 5, 0, Math.PI * 2, true)
            path.moveTo(95, 65)
            path.arc(90, 65, 5, 0, Math.PI * 2, true)
            ctx.strokeStyle = '#f60'
            ctx.stroke(path)
            // 3d
            // let gl = canvas.getContext('webgl')
        } else {
            console.log('你的浏览器不支持Canvas!');
        }
    }
    function testTextCanvas () {
        let canvas = document.getElementById('test-text-canvas')
        if (canvas.getContext) {
            // 2d
            let ctx = canvas.getContext('2d')
            ctx.clearRect(0, 0, canvas.width, canvas.height)
            ctx.shadowOffsetX = 2
            ctx.shadowOffsetY = 3
            ctx.shadowBlur = 2
            ctx.shadowColor = '#ff6942'
            ctx.font = '24px Arial'
            ctx.fillStyle = '#333'
            ctx.fillText('绘制文本', 20, 40)
            // 3d
            // let gl = canvas.getContext('webgl')
        } else {
            console.log('你的浏览器不支持Canvas!');
        }
    }
    function scaleCircle(){
        let canvas = document.getElementById('scaleCircle');
        if (!canvas.getContext) return;
        let context = canvas.getContext("2d");
        context.translate(250,20);
        for (var i = 0; i < 80; i++) {
            context.save(); //保存上一次画布的设置
            context.translate(30,30);//每次迭代新的原点都移动到上一次原坐标的(30,30)
            context.scale(0.95,0.95);//每次迭代横纵因子都缩小到原来的0.9倍
            context.rotate(Math.PI/12)//旋转
            context.beginPath();//开始进行绘制
            // context.fillStyle = "red";
            // context.globalAlpha="0.4";//设置颜色透明度
            context.fillStyle= "rgba(155, 187, 89, 0.7)";
            context.arc(0,0,50,0,Math.PI*2,true);//绘制圆
            context.closePath();
            context.fill();
        }
    }
    /**
     * 绘制矩形
     * 1、fillRect(x, y, width, height)：绘制一个填充的矩形。
     * 2、strokeRect(x, y, width, height)：绘制一个矩形的边框。
     * 3、clearRect(x, y, widh, height)：清除指定的矩形区域，然后这块区域会变的完全透明。
     * x, y：指的是矩形的左上角的坐标。(相对于canvas的坐标原点)
     * width, height：指的是绘制的矩形的宽和高。
     */
    function draw1 () {
        let canvas = document.getElementById('canvas1')
        if(!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.fillRect(10, 10, 100, 50) // 绘制矩形，填充的默认颜色为黑色
        ctx.strokeRect(10, 70, 100, 50) // 绘制矩形边框
        ctx.clearRect(15, 15, 50, 25); // 清除指定的矩形区域，然后这块区域会变的完全透明。
    }

    /**
     * 绘制路径 (path)
     *
     *  图形的基本元素是路径。
     *  路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。
     *  一个路径，甚至一个子路径，都是闭合的。
     *
     * 使用路径绘制图形需要一些额外的步骤：
     *   1.创建路径起始点
     *   2.调用绘制方法去绘制出路径
     *   3.把路径封闭
     *   4.一旦路径生成，通过描边或填充路径区域来渲染图形。
     * 下面是需要用到的方法：
     *    1.beginPath()   新建一条路径，路径一旦创建成功，图形绘制命令被指向到路径上生成路径
     *    2.moveTo(x, y)  把画笔移动到指定的坐标(x, y)。相当于设置路径的起始点坐标。
     *    3.closePath()   闭合路径之后，图形绘制命令又重新指向到上下文中
     *    4.stroke()      通过线条来绘制图形轮廓
     *    5.fill()        通过填充路径的内容区域生成实心的图形
     */
    // 绘制线段
    function draw2 () {
        let canvas = document.getElementById('canvas2')
        if(!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.font = '16px Arial'
        ctx.fillText('绘制线段', 50, 40)
        ctx.beginPath(); // 新建一条path
        ctx.moveTo(50, 50); // 把画笔移动到指定的坐标
        ctx.lineTo(200, 50); // 绘制一条从当前位置到指定坐标(200, 50)的直线.
        // ctx.closePath(); // 闭合路径。会拉一条从当前点到path起始点的直线。如果当前点与起始点重合，则什么都不做
        ctx.stroke(); // 绘制路径。

    }
    // 绘制三角形两条边框
    function draw3 () {
        let canvas = document.getElementById('canvas3')
        if(!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.font = '16px Microsoft YaHei'
        ctx.fillText('绘制三角形两条边框', 50, 40)
        ctx.beginPath();
        ctx.moveTo(50, 50);
        ctx.lineTo(200, 50);
        ctx.lineTo(200, 200);
        ctx.stroke();

    }
    // 绘制三角形边框
    function draw4 () {
        let canvas = document.getElementById('canvas4')
        if(!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.font = '14px Microsoft YaHei'
        ctx.fillText('绘制三角形边框，closePath关闭一条', 30, 40)
        ctx.beginPath();
        ctx.moveTo(50, 50);
        ctx.lineTo(200, 50);
        ctx.lineTo(200, 200);
        ctx.closePath(); // 虽然我们只绘制了两条线段，但是closePath会closePath，首尾相连，仍然是一个3角形
        ctx.stroke();
    }
    // 绘制三角形填充
    function draw5 () {
        let canvas = document.getElementById('canvas5')
        if(!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.font = '14px Microsoft YaHei'
        ctx.fillText('绘制三角形边框，closePath关闭一条', 30, 40)
        ctx.beginPath(); // 新建一条path
        ctx.moveTo(50, 50); // 把画笔移动到指定的坐标
        ctx.lineTo(200, 50); // 绘制一条从当前位置到指定坐标(200, 50)的直线.
        // ctx.closePath(); // 闭合路径。会拉一条从当前点到path起始点的直线。如果当前点与起始点重合，则什么都不做
        ctx.lineTo(200, 200);
        ctx.closePath(); // 虽然我们只绘制了两条线段，但是closePath会closePath，首尾相连，仍然是一个3角形
        ctx.stroke();// 绘制路径。
        ctx.fillStyle = '#f90' // 填充样式 默认#000
        ctx.fill(); // 填充闭合区域。如果path没有闭合，则fill()会自动闭合路径。
    }

    /**
     * 绘制圆弧
     * 有两个方法可以绘制圆弧：
     * 1. arc(x, y, r, startAngle, endAngle, anticlockwise):
     * 以(x, y)为圆心，以r为半径，从 startAngle弧度开始到endAngle弧度结束。anticlosewise是布尔值，true表示逆时针，false表示顺时针(默认是顺时针)。
     *   注意：
     *       1. 这里的度数都是弧度。
     *       2. 0 弧度是指的 x 轴正方形。
     *       radians=(Math.PI/180)*degrees   //角度转换成弧度
     * 2、arcTo(x1, y1, x2, y2, radius): 根据给定的控制点和半径画一段圆弧，最后再以直线连接两个控制点。
     */
    function draw6(){
        let canvas = document.getElementById('canvas6');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.beginPath(); // 新建一条path
        ctx.fillText('arc(50, 50, 40, 0, Math.PI / 2, false)', 50, 40)
        ctx.arc(50, 50, 40, 0, Math.PI / 2, false);  // 以(50, 50)为圆心，以40为半径，从0弧度开始到90弧度结束。false表示顺时针(默认是顺时针)。
        ctx.stroke(); // 绘制路径。
    }
    // 同时画多个图形
    function draw7(){
        let canvas = document.getElementById('canvas7');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.beginPath();
        ctx.fillText('arc(50, 50, 40, 0, Math.PI / 2, false)', 50, 210)
        ctx.arc(50, 50, 40, 0, Math.PI / 2, false);
        ctx.stroke();

        ctx.beginPath();
        ctx.fillText('arc(150, 50, 40, 0, -Math.PI / 2, true)', 50, 230)
        ctx.arc(150, 50, 40, 0, -Math.PI / 2, true);
        ctx.closePath();
        ctx.stroke();

        ctx.beginPath();
        ctx.fillStyle = '#960' // 填充样式 默认#000
        ctx.fillText('arc(50, 150, 40, -Math.PI / 2, Math.PI / 2, false)', 50, 250)
        ctx.arc(50, 150, 40, -Math.PI / 2, Math.PI / 2, false);
        ctx.fill();

        ctx.beginPath();
        ctx.fillStyle = '#f90' // 填充样式 默认#000
        ctx.fillText('arc(150, 150, 40, 0, Math.PI, false)', 50, 270)
        ctx.arc(150, 150, 40, 0, Math.PI, false);
        ctx.fill();
    }
    // arcTo 方法的说明：
    // 这个方法可以这样理解。绘制的弧形是由两条切线所决定。
    // 第 1 条切线：起始点和控制点1决定的直线。
    // 第 2 条切线：控制点1 和控制点2决定的直线。
    // 其实绘制的圆弧就是与这两条直线相切的圆弧。
    function draw8(){
        let canvas = document.getElementById('canvas8');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.beginPath(); // 新建一条path
        ctx.fillText('arcTo(200, 50, 200, 200, 100)', 50, 40)
        ctx.moveTo(50, 50); // 画笔起始点
        ctx.arcTo(200, 50, 200, 200, 100) // 参数1、2：控制点1坐标   参数3、4：控制点2坐标  参数4：圆弧半径
        ctx.lineTo(200, 200)
        ctx.stroke(); // 绘制路径。
    }

    /**
     * 贝塞尔曲线(Bezier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。
     * 一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，
     * 节点是可拖动的支点，线段像可伸缩的皮筋，我们在绘图工具上看到的钢笔工具就是来做这种矢量曲线的。
     * https://cubic-bezier.com/#0,1.95,1,-0.69
     *   绘制二次贝塞尔曲线:
     *      quadraticCurveTo(cp1x, cp1y, x, y)  // cp1x, cp1y：控制点坐标  x, y：结束点坐标
     *   绘制三次贝塞尔曲线:
     *      bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)  // cp1x, cp1y：控制点1的坐标  cp2x, cp2y：控制点1的坐标  x, y：结束点坐标
     */
    // 绘制二次贝塞尔曲线
    function draw9(){
        let canvas = document.getElementById('canvas9');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.beginPath(); // 新建一条path
        ctx.moveTo(10, 200); // 起始点
        let cp1x = 40, cp1y = 100;  //控制点
        let x = 200, y = 200; // 结束点
        ctx.quadraticCurveTo(cp1x, cp1y, x, y); // 绘制二次贝塞尔曲线
        ctx.stroke(); // 绘制路径。

        ctx.beginPath(); // 描点

        ctx.rect(10, 200, 5, 5); // 起始点
        ctx.fillText('起始点', 20, 200)
        ctx.rect(cp1x, cp1y, 5, 5); // 控制点
        ctx.fillText('控制点1', cp1x+10, cp1y)
        ctx.rect(x, y, 5, 5); // 结束点
        ctx.fillText('结束点', x+10, y)
        ctx.fill();
    }
    // 绘制三次贝塞尔曲线
    function draw10(){
        let canvas = document.getElementById('canvas10');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.beginPath();
        ctx.moveTo(40, 200); //起始点
        let cp1x = 20, cp1y = 100;  //控制点1
        let cp2x = 100, cp2y = 120;  //控制点2
        let x = 200, y = 200; // 结束点
        //绘制二次贝塞尔曲线
        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
        ctx.stroke();

        ctx.beginPath(); // 描点
        ctx.rect(40, 200, 5, 5);// 起始点
        ctx.fillText('起始点', 50, 200)
        ctx.rect(cp1x, cp1y, 5, 5); // 控制点1
        ctx.fillText('控制点1', cp1x+10, cp1y)
        ctx.rect(cp2x, cp2y, 5, 5); // 控制点2
        ctx.fillText('控制点2', cp2x+10, cp2y)
        ctx.rect(x, y, 5, 5); // 结束点
        ctx.fillText('结束点', x+10, y)
        ctx.fill();
    }

    /**
     * 添加样式和颜色
     * 在前面的绘制矩形章节中，只用到了默认的线条和颜色。
     * 如果想要给图形上色，有两个重要的属性可以做到。
     *   fillStyle = color 设置图形的填充颜色
     *   strokeStyle = color 设置图形轮廓的颜色
     *   说明
     *      1. color 可以是表示 css 颜色值的字符串、渐变对象或者图案对象。
     *      2. 默认情况下，线条和填充颜色都是黑色。
     *      3. 一旦您设置了 strokeStyle 或者 fillStyle 的值，那么这个新值就会成为新绘制的图形的默认值。
     *         如果你要给每个图形上不同的颜色，你需要重新设置 fillStyle 或 strokeStyle 的值。
     */
    // fillStyle
    function draw11 () {
        let canvas = document.getElementById('canvas11')
        if (!canvas.getContext) return
        let ctx = canvas.getContext('2d')
        for (let i = 0; i < 6; i++) {
            for (let j = 0; j < 6; j++) {
                ctx.fillStyle = 'rgb(' + Math.floor(255 - 42.5 * i) + ',' + Math.floor(255 - 42.5 * j) + ',0)' // 设置颜色
                ctx.fillRect(j * 50, i * 50, 50, 50) // 绘制矩形
            }
        }
    }
    // strokeStyle
    function draw12 () {
        let canvas = document.getElementById('canvas12')
        if (!canvas.getContext) return
        let ctx = canvas.getContext('2d')
        for (let i = 0; i < 6; i++) {
            for (let j = 0; j < 6; j++) {
                ctx.strokeStyle = `rgb(${randomInt(0, 255)},${randomInt(0, 255)},${randomInt(0, 255)})`
                ctx.strokeRect(5 + j * 50, 5 + i * 50, 40, 40)
            }
        }
    }
    /**
     返回随机的 [from, to] 之间的整数(包括from，也包括to)
     */
    function randomInt(from, to){
        return parseInt(Math.random() * (to - from + 1) + from);
    }

    /**
     * Transparency(透明度)
     * globalAlpha = transparencyValue: 这个属性影响到 canvas 里 所有 图形的透明度，
     *    有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。
     * globalAlpha 属性在需要绘制大量拥有相同透明度的图形时候相当高效。
     *
     * 不过，使用rgba()设置透明度更加好一些。
     */
    /**
     * 1、line style
     *    线宽。只能是正值。默认是 1.0。
     *    起始点和终点的连线为中心，上下各占线宽的一半。
     */

    function draw13 () {
        let canvas = document.getElementById('canvas13')
        if (!canvas.getContext) return
        let ctx = canvas.getContext('2d')
        ctx.beginPath();
        ctx.moveTo(10, 10);
        ctx.lineTo(100, 10);
        ctx.lineWidth = 10;
        ctx.strokeStyle = `rgb(${randomInt(0, 255)},${randomInt(0, 255)},${randomInt(0, 255)})`
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(110, 10);
        ctx.lineTo(160, 10)
        ctx.strokeStyle = `rgb(${randomInt(0, 255)},${randomInt(0, 255)},${randomInt(0, 255)})`
        ctx.lineWidth = 20;
        ctx.stroke()
    }

    /**
     * 2. lineCap = type
     *    线条末端样式。
     *    共有 3 个值：
     *    butt：线段末端以方形结束
     *    round：线段末端以圆形结束
     *    square：线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段厚度一半的矩形区域。
     */
    function draw14 () {
        let canvas = document.getElementById('canvas14')
        if (!canvas.getContext) return
        let ctx = canvas.getContext('2d')
        let lineCaps = ["butt", "round", "square"]; // 方形，圆形， 半个宽度矩形

        for (let i = 0; i < 3; i++){
            ctx.beginPath();
            ctx.moveTo(50 + 50 * i, 30);
            ctx.lineTo(50 + 50 * i, 100);
            ctx.lineWidth = 20;
            ctx.strokeStyle = `rgb(${randomInt(0, 255)},${randomInt(0, 255)},${randomInt(0, 255)})`
            ctx.lineCap = lineCaps[i];
            ctx.stroke();
        }

        ctx.beginPath();
        ctx.moveTo(0, 30);
        ctx.lineTo(300, 30);

        ctx.moveTo(0, 100);
        ctx.lineTo(300, 100)

        ctx.strokeStyle = "red";
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    /**
     * 3. lineJoin = type
     *    同一个 path 内，设定线条与线条间接合处的样式。
     *    共有 3 个值 round, bevel 和 miter：
     *        round 通过填充一个额外的，圆心在相连部分末端的扇形，绘制拐角的形状。 圆角的半径是线段的宽度。
     *        bevel 在相连部分的末端填充一个额外的以三角形为底的区域， 每个部分都有各自独立的矩形拐角。
     *        miter(默认) 通过延伸相连部分的外边缘，使其相交于一点，形成一个额外的菱形区域。
     */
    function draw15 (){
        let canvas = document.getElementById('canvas15');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");

        let lineJoin = ['round', 'bevel', 'miter'];
        ctx.lineWidth = 20;

        for (let i = 0; i < lineJoin.length; i++){
            ctx.lineJoin = lineJoin[i];
            ctx.strokeStyle = `rgb(${randomInt(0, 255)},${randomInt(0, 255)},${randomInt(0, 255)})`
            ctx.beginPath();
            let padding = 80
            ctx.moveTo(50, 50 + i * padding);
            ctx.lineTo(100, 100 + i * padding);
            ctx.lineTo(150, 50 + i * padding);
            ctx.lineTo(200, 100 + i * padding);
            ctx.lineTo(250, 50 + i * padding);
            ctx.stroke();
        }
    }

    /**
     * 4. 虚线
     *     用 setLineDash 方法和 lineDashOffset 属性来制定虚线样式。
     *     setLineDash 方法接受一个数组，来指定线段与间隙的交替；lineDashOffset属性设置起始偏移量。
     *     getLineDash() 返回一个包含当前虚线样式，长度为非负偶数的数组。
     */
    function draw16 (){
        let canvas = document.getElementById('canvas16');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");

        ctx.setLineDash([16, 5]);  // [实线长度, 间隙长度]
        // ctx.lineDashOffset = -0; // 起始偏移量
        ctx.lineDashOffset = 8; // 起始偏移量
        ctx.strokeRect(50, 50, 210, 210);
        console.log('虚线样式', ctx.getLineDash());
    }

    /**
     * 六、绘制文本
     * 绘制文本的两个方法
     *     fillText(text, x, y [, maxWidth]) 在指定的 (x,y) 位置填充指定的文本，绘制的最大宽度是可选的。
     *     strokeText(text, x, y [, maxWidth]) 在指定的 (x,y) 位置绘制文本边框，绘制的最大宽度是可选的。
     * 给文本添加样式
     *     font = value 当前我们用来绘制文本的样式。这个字符串使用和 CSS font 属性相同的语法。 默认的字体是 10px sans-serif。
     *     textAlign = value 文本对齐选项。 可选的值包括：start, end, left, right or center。 默认值是 start。
     *     textBaseline = value 基线对齐选项，可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。。
     *     direction = value 文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。
     */
    function draw17 (){
        let canvas = document.getElementById('canvas17');
        if (!canvas.getContext) return;
        ctx = canvas.getContext("2d");
        ctx.font = "36px sans-serif"; // 字体大小 字体样式
        ctx.textAlign = 'left';
        ctx.textBaseline = 'middle'
        ctx.direction = 'ltr'
        ctx.fillText("世人都说神仙好", 10, 100);
        ctx.strokeText("惟有功名忘不了", 10, 200);
    }

    /**
     * 七、绘制图片
     * 我们也可以在 canvas 上直接绘制图片。
     * 由零开始创建图片
     *      var img = new Image();   // 创建一个<img>元素
     *      img.src = 'myImage.png'; // 设置图片源地址
     * 绘制 img
     *      ctx.drawImage(img,0,0);  // 参数 1：要绘制的img,  参数 2、3：绘制的 img 在 canvas 中的坐标
     *
     * 注意：考虑到图片是从网络加载，如果 drawImage 的时候图片还没有完全加载完成，则什么都不做，个别浏览器会抛异常。所以我们应该保证在 img 绘制完成之后再 drawImage。
     *    var img = new Image();   // 创建img元素
     *         img.onload = function(){
     *        ctx.drawImage(img, 0, 0)
     *    }
     *    img.src = 'myImage.png'; // 设置图片源地址
     *
     * 绘制 img 标签元素中的图片
     * img 可以 new 也可以来源于我们页面的 <img>标签。
     *
     * 缩放图片
     *     drawImage(image, x, y, width, height) // 图片 x，y 坐标  width, height  图片尺寸
     * 切片(slice)
     *     drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)  // 图片 前4个是定义图像源的切片位置和大小，后4个则是定义切片的目标显示位置和大小。
     */
    // new 一个 Image
    function draw18 (){
        let canvas = document.getElementById('canvas18');
        if (!canvas.getContext) return;
        ctx = canvas.getContext("2d");
        let img = new Image();   // 创建一个<img>元素
        img.src = './assets/canvas/666666.png'; // 设置图片源地址
        // 考虑到图片是从网络加载，如果 drawImage 的时候图片还没有完全加载完成，则什么都不做，个别浏览器会抛异常。所以我们应该保证在 img 绘制完成之后再 drawImage。
        // img.onload = function(){ // 多个canvas 会跑到最后一个canvas里面去
        //     ctx.drawImage(img, 0, 0);  // 参数 1：要绘制的img,  参数 2、3：绘制的 img 在 canvas 中的坐标
        // }
        ctx.drawImage(img,0,0);  // 参数 1：要绘制的img,  参数 2、3：绘制的 img 在 canvas 中的坐标
    }
    // 从img标签获取
    function draw19 (){
        let canvas = document.getElementById('canvas19');
        if (!canvas.getContext) return;
        ctx = canvas.getContext("2d");
        let img = document.querySelector(".img");   // 获取一个<img>元素
        console.log(img)
        ctx.drawImage(img, 50, 50);  // 参数 1：要绘制的img,  参数 2、3：绘制的 img 在 canvas 中的坐标
    }
    // // 缩放图片
    function draw20 (){
        let canvas = document.getElementById('canvas20');
        if (!canvas.getContext) return;
        ctx = canvas.getContext("2d");
        // let img = new Image();   // 创建一个<img>元素
        // img.src = './assets/canvas/鸟.jpg'; // 设置图片源地址
        let img = document.querySelector(".img1");
        ctx.drawImage(img,50, 50, 192, 108);  // 参数 1：要绘制的img,  参数 2、3：绘制的 img 在 canvas 中的坐标， 参数 4、5：绘制的img大小
    }
    // 切片
    function draw21 (){
        let canvas = document.getElementById('canvas21');
        if (!canvas.getContext) return;
        ctx = canvas.getContext("2d");
        // let img = new Image();   // 创建一个<img>元素
        // img.src = './assets/canvas/鸟.jpg'; // 设置图片源地址
        let img = document.querySelector(".img1");
        ctx.drawImage(img,50, 50, 1000, 800, 100, 100, 192, 108);  // 参数 1：要绘制的img,  前 4 个是定义图像源的切片位置和大小，后 4 个则是定义切片的目标显示位置和大小。
    }

    /**
     * 状态的保存和恢复
     * Saving and restoring state 是绘制复杂图形时必不可少的操作。
     *
     * save() 和 restore()
     * save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。
     * Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。
     * 1、关于 save() ：Canvas状态存储在栈中，每当save()方法被调用后，当前的状态就被推送到栈中保存。
     *    一个绘画状态包括：
     *       1. 当前应用的变形（即移动，旋转和缩放）
     *       2. strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit,
     *          shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation 的值
     *       3. 当前的裁切路径（clipping path）
     * *** 可以调用任意多次 save方法(类似数组的 push())。
     * 2、关于restore()：每一次调用 restore 方法，上一个保存的状态就从栈中弹出，所有设定都恢复(类似数组的 pop())。
     */
    function draw22(){
        let canvas = document.getElementById('canvas22');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");

        ctx.fillRect(0, 0, 150, 150);   // 使用默认设置绘制一个矩形
        ctx.save();                  // 保存默认状态

        ctx.fillStyle = '#f90'       // 在原有配置基础上对颜色做改变
        ctx.fillRect(15, 15, 120, 120); // 使用新的设置绘制一个矩形
        ctx.save();                  // 保存当前状态

        ctx.fillStyle = '#fff'       // 再次改变颜色配置
        ctx.fillRect(30, 30, 90, 90);   // 使用新的配置绘制一个矩形

        ctx.restore();               // 重新加载之前的颜色状态
        ctx.fillRect(45, 45, 60, 60);   // 使用上一次的配置绘制一个矩形

        ctx.restore();               // 加载默认颜色配置
        ctx.fillRect(60, 60, 30, 30);   // 使用加载的配置绘制一个矩形
    }

    /**
     * 变形
     * 1、translate  用来移动 canvas 的**原点**到指定的位置
     *      translate(x, y) // x 是左右偏移量，y 是上下偏移量
     *
     *   在做变形之前先保存状态是一个良好的习惯。大多数情况下，调用 restore 方法比手动恢复原先的状态要简单得多。
     *   又如果你是在一个循环中做位移但没有保存和恢复 canvas 的状态，很可能到最后会发现怎么有些东西不见了，那是因为它很可能已经超出 canvas 范围以外了。
     *
     *   注意：translate 移动的是 canvas 的坐标原点(坐标变换)。
     * 2、rotate  旋转坐标轴。
     *      rotate(angle)  // angle 旋转的角度 它是顺时针方向的，以弧度为单位的值。旋转的中心是坐标原点。
     * 3、scale   增减图形在 canvas 中的像素数目，对形状，位图进行缩小或者放大。
     *      scale(x, y)  // x,y分别是横轴和纵轴的缩放因子，它们都必须是正值。值比 1.0 小表示缩 小，比 1.0 大则表示放大，值为 1.0 时什么效果都没有。
     * 4.transform(变形矩阵)
     *      transform(a, b, c, d, e, f)
     *          a 水平缩放
     *          b 水平偏斜
     *          c 垂直偏斜
     *          d 垂直缩放
     *          e 水平移动
     *          f 垂直移动
     */
    // translate
    function draw23() {
        let canvas = document.getElementById('canvas23');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.save(); // 保存坐原点平移之前的状态
        ctx.translate(80, 80); // 移动原点
        ctx.strokeRect(0, 10, 80, 80);

        ctx.restore(); // 恢复到最初状态
        ctx.strokeStyle = '#990';
        ctx.strokeRect(10, 10, 80, 80);

        ctx.translate(210, 210);  // 移动原点
        ctx.fillStyle = '#f90';
        ctx.fillRect(0, 0, 80, 80);
    }
    // rotate
    function draw24() {
        let canvas = document.getElementById('canvas24');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.fillStyle = '#f90';
        ctx.save();

        ctx.translate(100, 100);
        ctx.rotate(Math.PI / 180 *45); // 旋转45度
        ctx.fillStyle = '#f90';
        ctx.fillRect(0, 0, 100, 100)
        ctx.restore();

        ctx.save();
        ctx.translate(0, 0);
        ctx.fillRect(0, 0, 50, 50)
        ctx.restore();
    }
    // scale
    function draw25() {
        let canvas = document.getElementById('canvas25');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.beginPath(); // 新建一条path
        ctx.moveTo(50, 50); // 把画笔移动到指定的坐标
        ctx.lineTo(200, 50); // 绘制一条从当前位置到指定坐标(200, 50)的直线.
        ctx.scale(1, 0.5)
        ctx.stroke();
    }
    // transform
    function draw26 (){
        let canvas = document.getElementById('canvas26');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.transform(1, 1, 0, 1, 0, 0);
        ctx.fillRect(0, 0, 100, 100);
    }

    /**
     * 合成
     *   globalCompositeOperation = type
     *     type
     *        1.source-over 默认设置，新图像会覆盖在原有图像。
     *        2.source-in 仅仅会出现新图像与原来图像重叠部分的新图像，其他区域都变成透明的。(包括其他的老图像区域也会透明)
     *        3.source-out 仅仅显示新图像与老图像没有重叠部分的新图像，其余部分全部透明。(老图像也不显示)
     *        4.source-atop 新图像仅仅显示与老图像重叠区域。老图像仍然可以显示。
     *        5.destination-over 新图像会在老图像的下面。
     *        6.destination-in 仅仅新老图像重叠部分的老图像被显示，其他区域全部透明。
     *        7.destination-out 仅仅老图像与新图像没有重叠的部分。 注意显示的是老图像的部分区域。
     *        8.destination-atop 老图像仅仅仅仅显示重叠部分，新图像会显示在老图像的下面。
     *        9.lighter 新老图像都显示，但是重叠区域的颜色做加处理。(每个颜色位进行相加) blue: #0066ff  red: #ff6600  所以重叠部分的颜色：#ffccff。
     *        10.darken 保留重叠部分最黑的像素。(每个颜色位进行比较，得到最小的)  blue: #0000ff  red: #ff0000  所以重叠部分的颜色：#000000。
     *        11.lighten 保证重叠部分最亮的像素。(每个颜色位进行比较，得到最大的) blue: #0000ff  red: #ff0000  所以重叠部分的颜色：#ff00ff。
     *        12.xor 重叠部分会变成透明。
     *        13.copy 只有新图像会被保留，其余的全部被清除(边透明)。
     *
     */
    // source-over
    function draw27 () {
        let canvas = document.getElementById('canvas27');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.fillStyle = '#f90';
        ctx.fillRect(0, 0, 200, 200);
        ctx.globalCompositeOperation = 'source-over'; // 全局合成操作

        ctx.fillStyle = '#09f';
        ctx.fillRect(100, 100, 200, 200);
    }
    // source-in
    function draw28 () {
        let canvas = document.getElementById('canvas28');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.fillStyle = '#f90';
        ctx.fillRect(0, 0, 200, 200);
        ctx.globalCompositeOperation = 'source-in'; // 全局合成操作

        ctx.fillStyle = '#09f';
        ctx.fillRect(100, 100, 200, 200);
    }
    // source-out
    function draw29 () {
        let canvas = document.getElementById('canvas29');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.fillStyle = '#f90';
        ctx.fillRect(0, 0, 200, 200);
        ctx.globalCompositeOperation = 'source-out'; // 全局合成操作

        ctx.fillStyle = '#09f';
        ctx.fillRect(100, 100, 200, 200);
    }
    // source-atop
    function draw30 () {
        let canvas = document.getElementById('canvas30');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.fillStyle = '#f90';
        ctx.fillRect(0, 0, 200, 200);
        ctx.globalCompositeOperation = 'source-atop'; // 全局合成操作

        ctx.fillStyle = '#09f';
        ctx.fillRect(100, 100, 200, 200);
    }
    // destination-over
    function draw31 () {
        let canvas = document.getElementById('canvas31');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.fillStyle = '#f90';
        ctx.fillRect(0, 0, 200, 200);
        ctx.globalCompositeOperation = 'destination-over'; // 全局合成操作

        ctx.fillStyle = '#09f';
        ctx.fillRect(100, 100, 200, 200);
    }
    // destination-in
    function draw32 () {
        let canvas = document.getElementById('canvas32');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.fillStyle = '#f90';
        ctx.fillRect(0, 0, 200, 200);
        ctx.globalCompositeOperation = 'destination-in'; // 全局合成操作

        ctx.fillStyle = '#09f';
        ctx.fillRect(100, 100, 200, 200);
    }
    // destination-out
    function draw33 () {
        let canvas = document.getElementById('canvas33');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.fillStyle = '#f90';
        ctx.fillRect(0, 0, 200, 200);
        ctx.globalCompositeOperation = 'destination-out'; // 全局合成操作

        ctx.fillStyle = '#09f';
        ctx.fillRect(100, 100, 200, 200);
    }
    // destination-atop
    function draw34 () {
        let canvas = document.getElementById('canvas34');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.fillStyle = '#f90';
        ctx.fillRect(0, 0, 200, 200);
        ctx.globalCompositeOperation = 'destination-atop'; // 全局合成操作

        ctx.fillStyle = '#09f';
        ctx.fillRect(100, 100, 200, 200);
    }
    // lighter
    function draw35 () {
        let canvas = document.getElementById('canvas35');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        // ctx.fillStyle = '#f90';
        ctx.fillStyle = '#f60';
        ctx.fillRect(0, 0, 200, 200);
        ctx.globalCompositeOperation = 'lighter'; // 全局合成操作

        // ctx.fillStyle = '#09f';
        ctx.fillStyle = '#06f';
        // ctx.fillStyle = '#FFF'; // 全部相加
        // ctx.fillStyle = '#FCF'; // 全部相加

        ctx.fillRect(100, 100, 200, 200);
    }
    // darken
    function draw36 () {
        let canvas = document.getElementById('canvas36');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.fillStyle = '#f90';
        ctx.fillRect(0, 0, 200, 200);
        ctx.globalCompositeOperation = 'darken'; // 全局合成操作

        ctx.fillStyle = '#09f';
        // ctx.fillStyle = '#090';
        ctx.fillRect(100, 100, 200, 200);
    }
    // lighten
    function draw37 () {
        let canvas = document.getElementById('canvas37');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.fillStyle = '#f90';
        ctx.fillRect(0, 0, 200, 200);
        ctx.globalCompositeOperation = 'lighten'; // 全局合成操作

        ctx.fillStyle = '#09f';
        // ctx.fillStyle = '#f9f';
        ctx.fillRect(100, 100, 200, 200);
    }
    // xor
    function draw38 () {
        let canvas = document.getElementById('canvas38');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.fillStyle = '#f90';
        ctx.fillRect(0, 0, 200, 200);
        ctx.globalCompositeOperation = 'xor'; // 全局合成操作

        ctx.fillStyle = '#09f';
        ctx.fillRect(100, 100, 200, 200);
    }
    // copy
    function draw39 () {
        let canvas = document.getElementById('canvas39');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");
        ctx.fillStyle = '#f90';
        ctx.fillRect(0, 0, 200, 200);
        ctx.globalCompositeOperation = 'copy'; // 全局合成操作

        ctx.fillStyle = '#09f';
        ctx.fillRect(100, 100, 200, 200);
    }

    /**
     * 裁剪路径
     *     clip()
     *
     * 把已经创建的路径转换成裁剪路径。
     * 裁剪路径的作用是遮罩。只显示裁剪路径内的区域，裁剪路径外的区域会被隐藏。
     *     注意：clip() 只能遮罩在这个方法调用之后绘制的图像，如果是 clip() 方法调用之前绘制的图像，则无法实现遮罩。
     *
     */
    // clip()
    function draw40 () {
        let canvas = document.getElementById('canvas40');
        if (!canvas.getContext) return;
        let ctx = canvas.getContext("2d");

        ctx.beginPath();
        ctx.arc(70, 70, 50, 0, Math.PI * 2);
        ctx.clip()

        ctx.fillStyle = '#f90';
        ctx.fillRect(20, 20, 100, 100)
    }

    /**
     * 动画
     *  动画的基本步骤
     *      1.清空 canvas 再绘制每一帧动画之前，需要清空所有。清空所有最简单的做法就是 clearRect() 方法。
     *      2.保存 canvas 状态 如果在绘制的过程中会更改 canvas 的状态(颜色、移动了坐标原点等),又在绘制每一帧时都是原始状态的话，则最好保存下 canvas 的状态
     *      3.绘制动画图形这一步才是真正的绘制动画帧
     *      4.恢复 canvas 状态如果你前面保存了 canvas 状态，则应该在绘制完成一帧之后恢复 canvas 状态。
     *  控制动画
     *      我们可用通过 canvas 的方法或者自定义的方法把图像绘制到 canvas 上。正常情况，我们能看到绘制的结果是在脚本执行结束之后。
     *      例如，我们不可能在一个 for 循环内部完成动画。也就是，为了执行动画，我们需要一些可以定时执行重绘的方法。一般用到下面三个方法：
     *      setInterval()
     *      setTimeout()
     *      requestAnimationFrame()
     */
    let sun;
    let earth;
    let moon;
    // 案例1：太阳系
    function init(){
        sun = new Image();
        earth = new Image();
        moon = new Image();
        sun.src = "./assets/canvas/sun.png";
        earth.src = "./assets/canvas/earth.png";
        moon.src = "./assets/canvas/moon.png";
        sun.onload = function (){
            requestAnimationFrame(draw41);
        }
    }
    init();
    function draw41(){
        let canvas = document.querySelector("#canvas41");
        ctx = canvas.getContext("2d");
        // ctx.globalCompositeOperation = 'source-over';

        ctx.clearRect(0, 0, 300, 300); // 清空所有的内容
        /* 绘制 太阳*/
        ctx.drawImage(sun, 0, 0, 300, 300);

        ctx.save();
        ctx.translate(150, 150); // 移动原点为  太阳系中心
        ctx.fillStyle = '#f90'
        ctx.fillRect(-5, -5, 10, 10)

        let time = new Date();
        // 绘制地球
        ctx.rotate((2 * Math.PI / 60) * time.getSeconds() + (2 * Math.PI / 60000) * time.getMilliseconds()) // 旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。
        ctx.translate(100, 0);
        ctx.drawImage(earth, -12, -12)

        // 绘制earth轨道
        ctx.beginPath();
        ctx.translate(-100, 0);
        ctx.strokeStyle = "rgba(213,255,14,0.44)";
        ctx.arc(0, 0, 100, 0, 2 * Math.PI)
        ctx.stroke()

        // 绘制月球轨道
        ctx.beginPath();
        ctx.translate(100, 0);
        ctx.strokeStyle = "rgba(255,255,255,.3)";
        ctx.arc(0, 0, 40, 0, 2 * Math.PI);
        ctx.stroke();

        // 绘制月球
        ctx.rotate(2 * Math.PI / 6 * time.getSeconds() + 2 * Math.PI / 6000 * time.getMilliseconds());
        ctx.translate(40, 0);
        ctx.drawImage(moon, -3.5, -3.5);
        ctx.restore();

        requestAnimationFrame(draw41);
    }

    window.onload = () => {
        testCanvas()
        testTextCanvas()
        scaleCircle()
        draw1()
        draw2()
        draw3()
        draw4()
        draw5()
        draw6()
        draw7()
        draw8()
        draw9()
        draw10()
        draw11()
        draw12()
        draw13()
        draw14()
        draw15()
        draw16()
        draw17()
        draw18()
        // draw19()
        document.querySelector(".img").onclick = function (){
            draw19 ();
        }
        draw20()
        draw21()
        draw22()
        draw23()
        draw24()
        draw25()
        draw26()
        draw27()
        draw28()
        draw29()
        draw30()
        draw31()
        draw32()
        draw33()
        draw34()
        draw35()
        draw36()
        draw37()
        draw38()
        draw39()
        draw40()
    }
</script>
</html>
